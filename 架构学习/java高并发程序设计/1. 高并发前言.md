### 为什么需要并行？？
1. 并行计算只有在 图像处理 和 服务端编程 2个领域广泛使用。
2. 摩尔定律的失效，芯片性能提高速度变慢。
3. 硬件设计者无计可施。
4. 业务模型的需要。


### 同步（synchronous）和异步（asynchronous）
同步和异步关注的是消息通信机制。

- 同步：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。
- 异步：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理，这样就可以提高执行的效率了，
      即异步是我们发出的一个请求，该请求会在后台自动发出并获取数据，然后对数据进行处理，
      在此过程中，我们可以继续做其他操作，不管它怎么发出请求，不关心它怎么处理数据
      
### 并发（Concurrency）和并行（Parallelism）
- 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。
- 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，
                  但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行
                  
### 临界区

- 临界区：用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程
        使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待

### 阻塞（Blocking）和非阻塞（Non-Blocking）

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。。

- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程

### 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）

- 死锁：静态问题，不占用cpu
- 饥饿：指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行
- 活锁：电梯遇人，动态问题，很难排查

+ 并发级别
   * 阻塞：当一个线程进入临界区后，其他线程必须等待
   * 无障碍（Obstruction-Free）：
      - 无障碍是一种最弱的非阻塞调度
      - 自由出入临界区
      - 无竞争时，有限步内完成操作
      - 有竞争时，回滚数据
   * 无锁（Lock-Free）：
      - 是无障碍的
      - 保证有一个线程可以胜出
   * 无等待（Wait-Free）：
      - 无锁的
      - 要求所有的线程都必须在有限步内完成
      - 无饥饿的
      
### 有关并行的两个重要定律
加速比定义：加速比=优化前系统耗时/优化后系统耗时
Amdahl定律（阿姆达尔定律）：定义了串行系统并行化后的加速比的计算公式和理论上限

增加CPU处理器的数量并不一定能起到有效的作用提高系统内可并行化的模块比重，合理增加并行处
理器数量，才能以最小的投入，得到最大的加速比

Gustafson定律（古斯塔夫森）：说明处理器个数，串行比例和加速比之间的关系

只要有足够的并行化，那么加速比和CPU个数成正比